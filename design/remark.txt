
问题1： client一旦注册了,就不会被消除,不管他是否活跃,这样肯定会有问题的,注册中心ConcurrentSkipListMap会越来越大
问题2：心跳是client发起的   显然server没有办法知道client是否已经消亡，为什么是这样呢？
问题3：通信框架是基于socket+线程池实现的，这里可以进行优化，参考selector 或者epoll的设计




通信过程备注：
1 帧格式：[MagicNum(4byte)] + [version(1byte)] + [dataLength(4byte)] + [data(Message)] read的操作就是一步一步解帧的过程
          最终的data会通过fastjson统一的对象


2 加密过程：
           /**
          * 1.从密钥库里获取自己的私钥
          * 2.私钥用生成签名
          * 3.把签名和明文拼接，然后加密（对称加密）
          * 4.用对方的公钥加密第三步生成的秘文
          * 5.拼接对称密钥+密文
          */

3 解密过程
         /**
          * 1.从密钥库里获取自己的私钥，并分离获取对称密钥（密文的格式[对称密钥]+[秘文]）
          * 2.用自己的私钥解密
          * 3.用获取的对称密钥解密
          * 4.拆分签名和明文
          * 5.验证签名
          */


4 websocket
        在WebSocket出现之前，很多网站为了实现实时推送技术，通常采用的方案是轮询(Polling)和Comet技术，
        Comet又可细分为两种实现方式，一种是长轮询机制，一种称为流技术，这两种方式实际上是对轮询技术的
        改进，这些方案带来很明显的缺点，需要由浏览器对服务器发出HTTP request，大量消耗服务器带宽和资源
        。面对这种状况，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽并实现真正意义上的实时推
        送。WebSocket协议本质上是一个基于TCP的协议，它由通信协议和编程API组成，WebSocket能够在浏览器和
        服务器之间建立双向连接，以基于事件的方式，赋予浏览器实时通信能力。既然是双向通信，就意味着服务器
        端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应。为了建立一个WebSocket连接，客户端浏览
        器首先要向服务器发起一个HTTP请求，这个请求和通常的HTTP请求不同，包含了一些附加头信息，其中附加头信
        息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求，服务器端解析这些附加的头信息然后产生应答
        信息返回给客户端，客户端和服务器端的WebSocket连接就建立起来了，双方就可以通过这个连接通道自由的传递
        信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。



